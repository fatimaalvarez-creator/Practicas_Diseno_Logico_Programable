// módulo para password, mi password es '2010', si se levantan los sw correctos manda 'done', sino 'error'
module password(
	input clk, // reloj
			rst, // reset
	input [9:0] SW, // 10 bits, switches
	output done, // salida 'done'
	output error // salida 'error'
);

// definir parámetros todos los estados involucrados
localparam IDLE = 0; // estado ideal
localparam P_DIG = 1; // primer dígito
localparam S_DIG = 2; // segundo dígito
localparam T_DIG = 3; // tercer dígito
localparam DONE = 4; // estado de 'done'
localparam ERROR = 5; // estado de ''error'

// declarar 2 registros de igual tamaño
reg [2:0] current_state; // 3 bits
reg [2:0] next_state; // 3 bits
wire [9:0] sw_one_shot;

// primer always (MEMORIA), depende del reloj, actualiza el current_state 
always @(posedge clk or negedge rst)
	begin
		if(!rst) // cuando no es 0, es decir, es 1
			current_state <= IDLE; // IDLE el estado conocido, el deseado
		else
			current_state <= next_state;
	end

// segundo always, depende del estado actual de las señales de ENTRADA
always @(current_state, SW)
	begin
	next_state = current_state;
	case (current_state) // cuando es 1
        
		  IDLE: 
			begin
            if (SW == 0)	// cuando no hay ningún switch
					begin
					 next_state = IDLE; // se va al estado ideal
					 end
            else
					begin
						if (SW[2] == 1) // 2
							next_state <= DONE; 
						else
							next_state <= ERROR; 
					end
			end
			
        P_DIG: 
			begin
           if (SW == 0)	// cuando no hay ningún switch
					begin
					 next_state = P_DIG; // se mantiene en el P_DIG
					end
            else
					begin
						if (SW[0] == 1) // 0
							next_state <= DONE; 
						else
							next_state <= ERROR; 
					end
			end		 
					 
        S_DIG: 
			begin
           if (SW == 0)	// cuando no hay ningún switch
					begin
					 next_state = S_DIG; // se mantiene en el S_DIG
					end
            else
					begin
						if (SW[1] == 1) // 1
							next_state <= DONE; 
						else
							next_state <= ERROR; 
					end
			end		
					 
        T_DIG: 
			begin
           if (SW == 0)	// cuando no hay ningún switch
					begin
					 next_state = T_DIG; // se mantiene en el T_DIG
					end
            else
					begin
						if (SW[1] == 1) // 1
							next_state <= DONE; 
						else
							next_state <= ERROR; 
					end
			end		
			
		  DONE: 
			begin
           if (SW == 0)	// cuando no hay ningún switch
				next_state = IDLE; // se va a IDLE
			  else 
				next_state = DONE; // se va a DONE
			end
					 
		  ERROR: 
          begin
           if (SW == 0)	// cuando no hay ningún switch
				next_state = IDLE; // se va a IDLE
			  else 
				next_state = DONE; // se va a DONE
			end
		 
		 default: 
			next_state <= IDLE;
			
    endcase
	end
 
// tercer always, depende del estado actual de las señales de SALIDA
always @(current_state, done, eror)
	begin
		case (current_state) // cuando es 1
			  
			  DONE:
				begin
					done <= 1;
					error <= 0;
				end
			  
			  ERROR:
				begin
					done <= 0;
					error <= 1;
				end
				
			  default:
				begin
					done <= 0;
					error <= 0;
				end
	  
		 endcase
	 end

// para 'for'	 
genvar i;

generate
    for (i = 0; i < 10 ; i = i + 1) 
		begin ONE_SHOT_INSTANCIADO
        one_shot(
            .clk(clk),
            .button_a(sw[i]),
            .button_one_shot(sw_one_shot[i])
        );
    end
endgenerate



endmodule